<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@1326.ve643e00e9220">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition@2.2144.v077a_d1928a_40"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@2.2144.v077a_d1928a_40">
      <jobProperties/>
      <triggers/>
      <parameters>
        <string>NAMESPACE</string>
        <string>REF</string>
        <string>IMAGE_TAG</string>
        <string>OLD_CHART_VERSION</string>
        <string>CHART_LOCATION</string>
        <string>KUBECONFIG</string>
        <string>CHART_VERSION</string>
        <string>RELEASE_NAME</string>
        <string>GIT_REPO</string>
        <string>TOKEN</string>
      </parameters>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>GIT_REPO</name>
          <description>URL of the Git repository</description>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <com.cloudbees.plugins.credentials.CredentialsParameterDefinition plugin="credentials@1271.v54b_1c2c6388a_">
          <name>TOKEN</name>
          <description>Private access token for the Git repository</description>
          <defaultValue></defaultValue>
          <required>false</required>
        </com.cloudbees.plugins.credentials.CredentialsParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>REF</name>
          <description>Branch or tag.</description>
          <defaultValue>1.0.1</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>IMAGE_TAG</name>
          <description>Image tag of the new version of operator to be installed</description>
          <defaultValue>0.435.67</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>CHART_VERSION</name>
          <description>Version of operator chart to be installed</description>
          <defaultValue>2.3.4</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>OLD_CHART_VERSION</name>
          <description>Current version of the operator</description>
          <defaultValue>2.3.4</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>RELEASE_NAME</name>
          <description>Name of the Helm release. NOTE that this should be the same as the current installed version&apos;s name.</description>
          <defaultValue>confluent-demo</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>CHART_LOCATION</name>
          <description>Absolute system path where the helm charts are located</description>
          <defaultValue>/var/lib/jenkins/helm-charts/2.3.4</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>NAMESPACE</name>
          <description>Namespace to install the operator chart</description>
          <defaultValue>cf</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <com.cloudbees.plugins.credentials.CredentialsParameterDefinition plugin="credentials@1271.v54b_1c2c6388a_">
          <name>KUBECONFIG</name>
          <description>Kubeconfig secret</description>
          <defaultValue></defaultValue>
          <required>true</required>
        </com.cloudbees.plugins.credentials.CredentialsParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@3769.v8b_e595e4d40d">
    <script>pipeline {
    agent any

    parameters {
        string(name: &apos;GIT_REPO&apos;, description: &apos;URL of the Git repository&apos;, defaultValue: &apos;&apos;)
        credentials(name: &apos;TOKEN&apos;, description: &apos;Private access token for the Git repository&apos;, defaultValue: &apos;&apos;, required: false)
        string(name: &apos;REF&apos;, description: &apos;Branch or tag.&apos;, trim: true, defaultValue: &apos;1.0.1&apos;)    
        string(name: &apos;IMAGE_TAG&apos;, description: &apos;Image tag of the new version of operator to be installed&apos;, trim: true, defaultValue: &apos;0.435.67&apos;)
        string(name: &apos;CHART_VERSION&apos;, description: &apos;Version of operator chart to be installed&apos;, trim: true, defaultValue: &apos;2.3.4&apos;)
        string(name: &apos;OLD_CHART_VERSION&apos;, description: &apos;Current version of the operator&apos;, trim: true, defaultValue: &apos;2.3.4&apos;)
        string(name: &apos;RELEASE_NAME&apos;, description: &apos;Name of the Helm release. NOTE that this should be the same as the current installed version\&apos;s name.&apos;, trim: true, defaultValue: &apos;confluent-demo&apos;)
        string(name: &apos;CHART_LOCATION&apos;, description: &apos;Absolute system path where the helm charts are located&apos;, trim: true, defaultValue: &apos;/var/lib/jenkins/helm-charts/2.3.4&apos;)
        string(name: &apos;NAMESPACE&apos;, description: &apos;Namespace to install the operator chart&apos;, trim: true, defaultValue: &apos;cf&apos;)
        credentials(name: &apos;KUBECONFIG&apos;, description: &apos;Kubeconfig secret&apos;, defaultValue: &apos;&apos;, required: true)        
        
    }

    stages {

    stage(&apos;git checkout&apos;) {
      steps {
        script {
            def token = params.TOKEN
            def repoUrl = params.GIT_REPO
            def repo = repoUrl.split(&apos;https://&apos;)            
            if (token) {
              withCredentials([string(credentialsId: params.TOKEN, variable: &apos;TOKEN&apos;)]) {
                sh &quot;&quot;&quot;
                  git clone -c advice.detachedHead=false --depth 1 --branch ${params.REF} https://\$TOKEN@${repo[1]} ${env.BUILD_NUMBER}
                &quot;&quot;&quot;
              }
           } else {
             sh &quot;&quot;&quot;
             git clone -c advice.detachedHead=false --depth 1 --branch ${params.REF} ${params.GIT_REPO} ${env.BUILD_NUMBER}
             &quot;&quot;&quot;
           }
        }
      }
    }

    stage(&apos;Check values.yaml&apos;) {
            steps {
                   dir(&quot;${env.BUILD_NUMBER}&quot;) {
                    sh &quot;&quot;&quot;
                        values_yaml=&quot;./values.yaml&quot;
                        if [ -f &quot;\$values_yaml&quot; ]; then
                            echo &quot;values.yaml present: \$values_yaml&quot;
                        else
                            echo &quot;Error: File does not exist: \$values_yaml&quot;
                            exit 1
                        fi
                    &quot;&quot;&quot;
                }
            }
        }

        stage(&apos;Check License&apos;) {
            steps {
                dir(&quot;${env.BUILD_NUMBER}&quot;) {
                    sh &quot;&quot;&quot;
                        license=\$(yq &apos;.licenseKey&apos; values.yaml)
                        if [[ &quot;\$license&quot; == &quot;null&quot; || &quot;\$license&quot; == &quot;&quot; ]]; then
                            echo &quot;Error: License key not found.&quot;
                            exit 1
                        else
                            echo &quot;License check successful.&quot;
                        fi
                    &quot;&quot;&quot;
                }
            }
        }

        stage(&apos;Check Operator Image&apos;) {
            steps {
                dir(&quot;${env.BUILD_NUMBER}&quot;) {
                    sh &quot;&quot;&quot;
                        image_tag=\$(yq &apos;.image.tag&apos; values.yaml)
                        if [[ &quot;\$image_tag&quot; == &quot;${params.IMAGE_TAG}&quot; ]]; then
                            echo &quot;Image tag check successful.&quot;
                        else
                            echo &quot;Error: Incorrect image tag. Found \$image_tag, expecting ${params.IMAGE_TAG}.&quot;
                            exit 1
                        fi
                    &quot;&quot;&quot;
                }
            }
        }

        stage(&apos;Check Installed Chart&apos;) {
            steps {
                withCredentials([file(credentialsId: params.KUBECONFIG, variable: &apos;KUBECONFIG&apos;)]) {
                    sh &quot;&quot;&quot;
                        status=\$(helm ls -n ${params.NAMESPACE} -o yaml | yq &apos;(.[] | select(.name == &quot;${params.RELEASE_NAME}&quot;) | .status)&apos;)
                        version=\$(helm ls -n ${params.NAMESPACE} -o yaml | yq &apos;(.[] | select(.name == &quot;${params.RELEASE_NAME}&quot;) | .app_version)&apos;)
                        echo &quot;Chart status is: \$status.&quot;
                        echo &quot;Chart version is: \$version.&quot;
                        if [ &quot;\$status&quot; != &quot;deployed&quot; ]; then
                            exit 1
                        fi
                        if [ &quot;\$version&quot; != &quot;${params.OLD_CHART_VERSION}&quot; ]; then
                            exit 1
                        fi
                    &quot;&quot;&quot;
                }
            }
        }

        stage(&apos;Stop Reconcile&apos;) {
            steps {
                withCredentials([file(credentialsId: params.KUBECONFIG, variable: &apos;KUBECONFIG&apos;)]) {
                    sh &quot;&quot;&quot;
                        kubectl annotate connect connect \\
                        platform.confluent.io/block-reconcile=true \\
                        --namespace ${params.NAMESPACE}
                        
                        kubectl annotate controlcenter controlcenter \\
                        platform.confluent.io/block-reconcile=true \\
                        --namespace ${params.NAMESPACE}
                        
                        kubectl annotate kafka kafka \\
                        platform.confluent.io/block-reconcile=true \\
                        --namespace ${params.NAMESPACE}
                        
                        kubectl annotate zookeeper zookeeper \\
                        platform.confluent.io/block-reconcile=true \\
                        --namespace ${params.NAMESPACE}
                    &quot;&quot;&quot;
                }
            }
        }

        stage(&apos;Update CRDs&apos;) {
            steps {
                withCredentials([file(credentialsId: params.KUBECONFIG, variable: &apos;KUBECONFIG&apos;)]) {
                script {
                  try {
                    sh &quot;&quot;&quot;
                        kubectl apply -f ${params.CHART_LOCATION}/helm/confluent-for-kubernetes/crds/
                    &quot;&quot;&quot;
                  } catch (Exception e) {
                    currentBuild.result = &apos;FAILURE&apos;
                    echo &quot;Update CRDs step failed but continuing the pipeline.&quot;
                  }
                }
                }
            }
        }

        stage(&apos;Replace CRDs&apos;) {
            steps {
                withCredentials([file(credentialsId: params.KUBECONFIG, variable: &apos;KUBECONFIG&apos;)]) {
                script {
                  try {
                    sh &quot;&quot;&quot;
                        kubectl replace -f ${params.CHART_LOCATION}/helm/confluent-for-kubernetes/crds/
                    &quot;&quot;&quot;
                  } catch (Exception e) {
                    currentBuild.result = &apos;FAILURE&apos;
                    echo &quot;Update CRDs step failed but continuing the pipeline.&quot;
                  }
                }
                }
            }
        }
        
        stage(&apos;Helm Install&apos;) {
            steps {
                dir(&quot;${env.BUILD_NUMBER}&quot;) {
                  withCredentials([file(credentialsId: params.KUBECONFIG, variable: &apos;KUBECONFIG&apos;)]) {
                    sh &quot;&quot;&quot;
                        helm upgrade --install \\
                        --atomic --timeout 300s \\
                        --namespace ${params.NAMESPACE} \\
                        --values values.yaml \\
                        ${params.RELEASE_NAME} \\
                        ${params.CHART_LOCATION}/helm/confluent-for-kubernetes
                    &quot;&quot;&quot;
                  }
                }
            }
        }

        stage(&apos;Start Reconcile&apos;) {
            steps {
                withCredentials([file(credentialsId: params.KUBECONFIG, variable: &apos;KUBECONFIG&apos;)]) {
                    sh &quot;&quot;&quot;
                        kubectl annotate connect connect \\
                        platform.confluent.io/block-reconcile- \\
                        --namespace ${params.NAMESPACE}
                        
                        kubectl annotate controlcenter controlcenter \\
                        platform.confluent.io/block-reconcile- \\
                        --namespace ${params.NAMESPACE}
                        
                        kubectl annotate kafka kafka \\
                        platform.confluent.io/block-reconcile- \\
                        --namespace ${params.NAMESPACE}
                        
                        kubectl annotate zookeeper zookeeper \\
                        platform.confluent.io/block-reconcile- \\
                        --namespace ${params.NAMESPACE}
                    &quot;&quot;&quot;
                }
            }
        }

        stage(&apos;Post install check&apos;) {
            steps {
                withCredentials([file(credentialsId: params.KUBECONFIG, variable: &apos;KUBECONFIG&apos;)]) {
                    sh &quot;&quot;&quot;
                        status=\$(helm ls -n ${params.NAMESPACE} -o yaml | yq &apos;(.[] | select(.name == &quot;${params.RELEASE_NAME}&quot;) | .status)&apos;)
                        version=\$(helm ls -n ${params.NAMESPACE} -o yaml | yq &apos;(.[] | select(.name == &quot;${params.RELEASE_NAME}&quot;) | .app_version)&apos;)
                        echo &quot;Chart status is: \$status.&quot;
                        echo &quot;Chart version is: \$version.&quot;
                        if [ &quot;\$status&quot; != &quot;deployed&quot; ]; then
                            exit 1
                        fi
                        if [ &quot;\$version&quot; != &quot;${params.CHART_VERSION}&quot; ]; then
                            exit 1
                        fi
                    &quot;&quot;&quot;
                }
            }
        }

    }
}</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>